# S-4.3 Message Scheduler Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Enable agents to autonomously initiate conversations on a schedule via a polling loop that fires due messages and enqueues agent runs.

**Architecture:** A `setInterval` polling loop (10s) in `src/scheduler/loop.ts` queries for due `scheduledMessages`, rate-limits per agent (1 fire / 5 min), enqueues runs via the existing mailbox, and marks messages as `'fired'`. The loop starts in `instrumentation.ts` on the Node.js runtime. A new optional `triggerPrompt` column on the `runs` table carries the scheduled prompt to the orchestrator. REST API routes expose CRUD for scheduled messages.

**Tech Stack:** Drizzle ORM, Next.js `instrumentation.ts`, Vitest, Zod, Sentry telemetry

---

## Task 1: Add `triggerPrompt` to Runs Schema

**Files:**
- Modify: `src/db/schema/runs.ts` (line ~39, add column after `channelId`)
- Modify: `src/db/queries/runs.ts` (line ~246, update `mapRowToRun`)
- Modify: `src/tests/factories/run.ts` (line ~14, add default)
- Test: `src/db/schema/__tests__/runs.test.ts`

**Step 1: Write failing test**

Add a test to `src/db/schema/__tests__/runs.test.ts`:

```typescript
it("has trigger_prompt as optional text column", () => {
  const col = runConfig.columns.find((c) => c.name === "trigger_prompt");
  expect(col).toBeDefined();
  expect(col?.dataType).toBe("string");
  expect(col?.notNull).toBe(false);
});
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run src/db/schema/__tests__/runs.test.ts --reporter=verbose`
Expected: FAIL — no column named `trigger_prompt`

**Step 3: Add column to schema**

In `src/db/schema/runs.ts`, add after `channelId`:

```typescript
triggerPrompt: text("trigger_prompt"),
```

**Step 4: Update `mapRowToRun` in queries**

In `src/db/queries/runs.ts`, add to the `mapRowToRun` function:

```typescript
triggerPrompt: (row.trigger_prompt as string | null) ?? null,
```

**Step 5: Update factory**

In `src/tests/factories/run.ts`, add to the default mock:

```typescript
triggerPrompt: null,
```

**Step 6: Run tests to verify they pass**

Run: `npx vitest run src/db/schema/__tests__/runs.test.ts --reporter=verbose`
Expected: PASS

**Step 7: Push schema to DB**

Run: `npm run db:push`

**Step 8: Commit**

```
feat(schema): add triggerPrompt column to runs table

Supports S-4.3 scheduler — carries the scheduled message prompt
to the orchestrator without creating visible channel messages.
```

---

## Task 2: Update Orchestrator to Use `triggerPrompt`

**Files:**
- Modify: `src/agents/orchestrator.ts` (line ~377, update `formatTriggerPrompt`)
- Test: `src/agents/__tests__/orchestrator.test.ts`

**Step 1: Write failing test**

Add to the orchestrator test file (there should be tests for `formatTriggerPrompt` or the trigger prompt behavior — if not, add one that verifies the SDK `query` call receives the triggerPrompt):

```typescript
it("uses triggerPrompt from run when present", async () => {
  const run = createMockRun({
    agentId: agent.id,
    channelId: "general",
    triggerPrompt: "Post your morning greeting to the team",
  });

  await executeRun(run);

  expect(mockQuery).toHaveBeenCalledWith(
    expect.objectContaining({
      prompt: "Post your morning greeting to the team",
    }),
  );
});
```

**Step 2: Run test to verify it fails**

Run: `npx vitest run src/agents/__tests__/orchestrator.test.ts --reporter=verbose`
Expected: FAIL — prompt doesn't match triggerPrompt

**Step 3: Update `formatTriggerPrompt`**

In `src/agents/orchestrator.ts`, replace:

```typescript
function formatTriggerPrompt(run: Run): string {
  if (run.triggerMessageId) {
    return `A new message was posted (trigger: ${run.triggerMessageId}). Review the recent conversation and decide how to respond.`;
  }
  return "Review the recent messages in the channel and decide how to respond.";
}
```

With:

```typescript
function formatTriggerPrompt(run: Run): string {
  if (run.triggerPrompt) {
    return run.triggerPrompt;
  }
  if (run.triggerMessageId) {
    return `A new message was posted (trigger: ${run.triggerMessageId}). Review the recent conversation and decide how to respond.`;
  }
  return "Review the recent messages in the channel and decide how to respond.";
}
```

**Step 4: Run tests**

Run: `npx vitest run src/agents/__tests__/orchestrator.test.ts --reporter=verbose`
Expected: PASS

**Step 5: Commit**

```
feat(orchestrator): support triggerPrompt in run execution

When a run has a triggerPrompt (from scheduler), use it directly
instead of the generic "review messages" prompt.
```

---

## Task 3: Create Scheduler DB Queries

**Files:**
- Create: `src/db/queries/scheduler.ts`
- Modify: `src/db/queries/index.ts` (add re-export)
- Test: `src/db/queries/__tests__/scheduler.test.ts`

**Step 1: Write failing tests**

Create `src/db/queries/__tests__/scheduler.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import type { ScheduledMessage, NewScheduledMessage } from "@/db/schema";

const mockDb = {
  select: vi.fn(),
  insert: vi.fn(),
  update: vi.fn(),
};

vi.mock("@/db/client", () => ({ db: mockDb }));

vi.mock("@sentry/nextjs", () => ({
  startSpan: (_opts: unknown, fn: () => unknown) => fn(),
}));

vi.mock("@/lib/telemetry", () => ({
  withSpan: (_name: string, _op: string, fn: () => unknown) => fn(),
  logInfo: vi.fn(),
}));

describe("scheduler queries", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("getDueMessages", () => {
    it("returns pending messages where triggerAt <= now", async () => {
      const mockMsg: ScheduledMessage = {
        id: "sched-1",
        agentId: "michael",
        triggerAt: new Date("2025-01-01"),
        prompt: "Morning greeting",
        targetChannelId: "general",
        status: "pending",
        createdAt: new Date("2025-01-01"),
      };

      // Chain: db.select().from().where() → [mockMsg]
      const mockWhere = vi.fn().mockResolvedValue([mockMsg]);
      const mockFrom = vi.fn().mockReturnValue({ where: mockWhere });
      mockDb.select.mockReturnValue({ from: mockFrom });

      const { getDueMessages } = await import("../scheduler");
      const result = await getDueMessages();

      expect(result).toEqual([mockMsg]);
      expect(mockDb.select).toHaveBeenCalled();
    });
  });

  describe("markFired", () => {
    it("updates status to fired", async () => {
      const mockReturning = vi.fn().mockResolvedValue([{ id: "sched-1", status: "fired" }]);
      const mockWhere = vi.fn().mockReturnValue({ returning: mockReturning });
      const mockSet = vi.fn().mockReturnValue({ where: mockWhere });
      mockDb.update.mockReturnValue({ set: mockSet });

      const { markFired } = await import("../scheduler");
      await markFired("sched-1");

      expect(mockDb.update).toHaveBeenCalled();
    });
  });

  describe("createScheduledMessage", () => {
    it("inserts and returns the new scheduled message", async () => {
      const input: NewScheduledMessage = {
        agentId: "michael",
        triggerAt: new Date("2025-01-01T09:00:00Z"),
        prompt: "Morning greeting",
        targetChannelId: "general",
      };
      const inserted = { ...input, id: "sched-new", status: "pending", createdAt: new Date() };

      const mockReturning = vi.fn().mockResolvedValue([inserted]);
      const mockValues = vi.fn().mockReturnValue({ returning: mockReturning });
      mockDb.insert.mockReturnValue({ values: mockValues });

      const { createScheduledMessage } = await import("../scheduler");
      const result = await createScheduledMessage(input);

      expect(result).toEqual(inserted);
    });
  });

  describe("cancelScheduledMessage", () => {
    it("sets status to cancelled and returns true", async () => {
      const mockReturning = vi.fn().mockResolvedValue([{ id: "sched-1", status: "cancelled" }]);
      const mockWhere = vi.fn().mockReturnValue({ returning: mockReturning });
      const mockSet = vi.fn().mockReturnValue({ where: mockWhere });
      mockDb.update.mockReturnValue({ set: mockSet });

      const { cancelScheduledMessage } = await import("../scheduler");
      const result = await cancelScheduledMessage("sched-1");

      expect(result).toBe(true);
    });

    it("returns false when no rows matched", async () => {
      const mockReturning = vi.fn().mockResolvedValue([]);
      const mockWhere = vi.fn().mockReturnValue({ returning: mockReturning });
      const mockSet = vi.fn().mockReturnValue({ where: mockWhere });
      mockDb.update.mockReturnValue({ set: mockSet });

      const { cancelScheduledMessage } = await import("../scheduler");
      const result = await cancelScheduledMessage("nonexistent");

      expect(result).toBe(false);
    });
  });

  describe("listScheduledMessages", () => {
    it("returns all scheduled messages ordered by triggerAt", async () => {
      const mockOrderBy = vi.fn().mockResolvedValue([]);
      const mockFrom = vi.fn().mockReturnValue({ orderBy: mockOrderBy });
      mockDb.select.mockReturnValue({ from: mockFrom });

      const { listScheduledMessages } = await import("../scheduler");
      const result = await listScheduledMessages();

      expect(result).toEqual([]);
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/db/queries/__tests__/scheduler.test.ts --reporter=verbose`
Expected: FAIL — module not found

**Step 3: Implement scheduler queries**

Create `src/db/queries/scheduler.ts`:

```typescript
import { eq, and, lte, desc } from "drizzle-orm";
import { db } from "@/db/client";
import {
  scheduledMessages,
  type ScheduledMessage,
  type NewScheduledMessage,
} from "@/db/schema";
import { withSpan } from "@/lib/telemetry";

export function getDueMessages(): Promise<ScheduledMessage[]> {
  return withSpan("getDueMessages", "db.query", () =>
    db
      .select()
      .from(scheduledMessages)
      .where(
        and(
          eq(scheduledMessages.status, "pending"),
          lte(scheduledMessages.triggerAt, new Date()),
        ),
      ),
  );
}

export function markFired(id: string): Promise<ScheduledMessage | undefined> {
  return withSpan("markFired", "db.query", async () => {
    const rows = await db
      .update(scheduledMessages)
      .set({ status: "fired" })
      .where(eq(scheduledMessages.id, id))
      .returning();
    return rows[0];
  });
}

export function createScheduledMessage(
  data: NewScheduledMessage,
): Promise<ScheduledMessage> {
  return withSpan("createScheduledMessage", "db.query", async () => {
    const rows = await db
      .insert(scheduledMessages)
      .values(data)
      .returning();
    const created = rows[0];
    if (!created) throw new Error("Insert returned no rows");
    return created;
  });
}

export function cancelScheduledMessage(id: string): Promise<boolean> {
  return withSpan("cancelScheduledMessage", "db.query", async () => {
    const rows = await db
      .update(scheduledMessages)
      .set({ status: "cancelled" })
      .where(
        and(
          eq(scheduledMessages.id, id),
          eq(scheduledMessages.status, "pending"),
        ),
      )
      .returning();
    return rows.length > 0;
  });
}

export function listScheduledMessages(): Promise<ScheduledMessage[]> {
  return withSpan("listScheduledMessages", "db.query", () =>
    db
      .select()
      .from(scheduledMessages)
      .orderBy(desc(scheduledMessages.triggerAt)),
  );
}
```

**Step 4: Update barrel export**

In `src/db/queries/index.ts`, add:

```typescript
export * from "./scheduler";
```

**Step 5: Run tests**

Run: `npx vitest run src/db/queries/__tests__/scheduler.test.ts --reporter=verbose`
Expected: PASS

**Step 6: Commit**

```
feat(db): add scheduler query functions

getDueMessages, markFired, createScheduledMessage,
cancelScheduledMessage, listScheduledMessages — all traced.
```

---

## Task 4: Create Scheduler Loop

**Files:**
- Modify: `src/agents/constants.ts` (add scheduler constants)
- Create: `src/scheduler/loop.ts`
- Test: `src/scheduler/__tests__/loop.test.ts`

**Step 1: Add constants**

In `src/agents/constants.ts`:

```typescript
/** How often the scheduler checks for due messages (ms). */
export const SCHEDULER_INTERVAL_MS = 10_000;

/** Minimum time between scheduled fires for the same agent (ms). */
export const SCHEDULER_RATE_LIMIT_MS = 300_000;
```

**Step 2: Write failing tests**

Create `src/scheduler/__tests__/loop.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import type { ScheduledMessage } from "@/db/schema";

const mockGetDueMessages = vi.fn<() => Promise<ScheduledMessage[]>>();
const mockMarkFired = vi.fn<(id: string) => Promise<unknown>>();
const mockEnqueueRun = vi.fn<(input: unknown) => Promise<unknown>>();

vi.mock("@/db/queries", () => ({
  getDueMessages: () => mockGetDueMessages(),
  markFired: (id: string) => mockMarkFired(id),
}));

vi.mock("@/agents/mailbox", () => ({
  enqueueRun: (input: unknown, executor?: unknown) =>
    mockEnqueueRun(input),
}));

vi.mock("@sentry/nextjs", () => ({
  startSpan: (_opts: unknown, fn: () => unknown) => fn(),
  captureException: vi.fn(),
}));

vi.mock("@/lib/telemetry", () => ({
  withSpan: (_name: string, _op: string, fn: () => unknown) => fn(),
  logInfo: vi.fn(),
  logWarn: vi.fn(),
  logError: vi.fn(),
  countMetric: vi.fn(),
  distributionMetric: vi.fn(),
}));

function createMockScheduledMessage(
  overrides?: Partial<ScheduledMessage>,
): ScheduledMessage {
  return {
    id: "sched-1",
    agentId: "michael",
    triggerAt: new Date("2025-01-01T09:00:00Z"),
    prompt: "Morning greeting",
    targetChannelId: "general",
    status: "pending",
    createdAt: new Date("2025-01-01"),
    ...overrides,
  };
}

describe("scheduler loop", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it("fires a due message by enqueuing a run and marking fired", async () => {
    const msg = createMockScheduledMessage();
    mockGetDueMessages.mockResolvedValue([msg]);
    mockMarkFired.mockResolvedValue({ ...msg, status: "fired" });
    mockEnqueueRun.mockResolvedValue({ id: "run-1" });

    const { tick } = await import("../loop");
    await tick();

    expect(mockGetDueMessages).toHaveBeenCalled();
    expect(mockEnqueueRun).toHaveBeenCalledWith(
      expect.objectContaining({
        agentId: "michael",
        channelId: "general",
        triggerPrompt: "Morning greeting",
      }),
    );
    expect(mockMarkFired).toHaveBeenCalledWith("sched-1");
  });

  it("skips agent if rate limited (fired within 5 min)", async () => {
    const msg = createMockScheduledMessage();
    mockGetDueMessages
      .mockResolvedValueOnce([msg])
      .mockResolvedValueOnce([
        createMockScheduledMessage({ id: "sched-2" }),
      ]);
    mockMarkFired.mockResolvedValue({ ...msg, status: "fired" });
    mockEnqueueRun.mockResolvedValue({ id: "run-1" });

    const { tick, clearRateLimits } = await import("../loop");
    await tick(); // fires sched-1
    await tick(); // sched-2 should be rate-limited

    expect(mockEnqueueRun).toHaveBeenCalledTimes(1);
    clearRateLimits();
  });

  it("does nothing when no messages are due", async () => {
    mockGetDueMessages.mockResolvedValue([]);

    const { tick } = await import("../loop");
    await tick();

    expect(mockEnqueueRun).not.toHaveBeenCalled();
    expect(mockMarkFired).not.toHaveBeenCalled();
  });

  it("startScheduler returns a stop function", async () => {
    mockGetDueMessages.mockResolvedValue([]);

    const { startScheduler } = await import("../loop");
    const stop = startScheduler();

    expect(typeof stop).toBe("function");
    stop();
  });

  it("fires for agent that was rate-limited after 5 minutes pass", async () => {
    const msg1 = createMockScheduledMessage();
    const msg2 = createMockScheduledMessage({ id: "sched-2" });

    mockGetDueMessages
      .mockResolvedValueOnce([msg1])
      .mockResolvedValueOnce([msg2]);
    mockMarkFired.mockResolvedValue({});
    mockEnqueueRun.mockResolvedValue({ id: "run-1" });

    const { tick, clearRateLimits } = await import("../loop");
    await tick(); // fires msg1 → rate-limits michael

    // Advance time past rate limit
    vi.advanceTimersByTime(300_001);

    await tick(); // should fire msg2
    expect(mockEnqueueRun).toHaveBeenCalledTimes(2);
    clearRateLimits();
  });
});
```

**Step 3: Run tests to verify they fail**

Run: `npx vitest run src/scheduler/__tests__/loop.test.ts --reporter=verbose`
Expected: FAIL — module not found

**Step 4: Implement scheduler loop**

Create `src/scheduler/loop.ts`:

```typescript
import { getDueMessages, markFired } from "@/db/queries";
import { enqueueRun } from "@/agents/mailbox";
import { executeRun } from "@/agents/orchestrator";
import {
  SCHEDULER_INTERVAL_MS,
  SCHEDULER_RATE_LIMIT_MS,
} from "@/agents/constants";
import {
  withSpan,
  logInfo,
  logWarn,
  logError,
  countMetric,
} from "@/lib/telemetry";

/** In-memory rate limit tracker: agentId → last fire timestamp. */
const lastFiredAt = new Map<string, number>();

/** Exported for testing — clears rate limit state. */
export function clearRateLimits(): void {
  lastFiredAt.clear();
}

function isRateLimited(agentId: string): boolean {
  const lastFire = lastFiredAt.get(agentId);
  if (!lastFire) return false;
  return Date.now() - lastFire < SCHEDULER_RATE_LIMIT_MS;
}

/**
 * Single tick: query due messages, fire eligible ones.
 * Exported for testing.
 */
export async function tick(): Promise<void> {
  return withSpan("scheduler.tick", "scheduler.loop", async () => {
    const dueMessages = await getDueMessages();

    if (dueMessages.length === 0) return;

    logInfo("scheduler: due messages found", { count: dueMessages.length });

    for (const msg of dueMessages) {
      if (isRateLimited(msg.agentId)) {
        logWarn("scheduler: rate limited", {
          scheduledId: msg.id,
          agentId: msg.agentId,
        });
        countMetric("scheduler.rate_limited", 1, { agentId: msg.agentId });
        continue;
      }

      try {
        await enqueueRun(
          {
            agentId: msg.agentId,
            channelId: msg.targetChannelId,
            triggerPrompt: msg.prompt,
          },
          executeRun,
        );

        await markFired(msg.id);
        lastFiredAt.set(msg.agentId, Date.now());

        logInfo("scheduler: message fired", {
          scheduledId: msg.id,
          agentId: msg.agentId,
          channelId: msg.targetChannelId ?? "none",
        });
        countMetric("scheduler.fired", 1, { agentId: msg.agentId });
      } catch (err) {
        logError("scheduler: fire failed", {
          scheduledId: msg.id,
          agentId: msg.agentId,
          error: err instanceof Error ? err.message : String(err),
        });
        countMetric("scheduler.fire_error", 1, { agentId: msg.agentId });
      }
    }
  });
}

/**
 * Starts the scheduler polling loop.
 * Returns a function to stop the loop.
 */
export function startScheduler(): () => void {
  logInfo("scheduler: starting", {
    intervalMs: SCHEDULER_INTERVAL_MS,
    rateLimitMs: SCHEDULER_RATE_LIMIT_MS,
  });

  const intervalId = setInterval(() => {
    void tick();
  }, SCHEDULER_INTERVAL_MS);

  return () => {
    clearInterval(intervalId);
    logInfo("scheduler: stopped");
  };
}
```

**Step 5: Run tests**

Run: `npx vitest run src/scheduler/__tests__/loop.test.ts --reporter=verbose`
Expected: PASS

**Step 6: Commit**

```
feat(scheduler): implement polling loop with rate limiting

10s interval, 5-min per-agent rate limit, enqueues runs via mailbox.
tick() and clearRateLimits() exported for testing.
```

---

## Task 5: Wire Scheduler to Instrumentation

**Files:**
- Modify: `src/instrumentation.ts`

**Step 1: Update instrumentation.ts**

Replace the current `register()` function:

```typescript
import * as Sentry from "@sentry/nextjs";

export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    await import("../sentry.server.config");

    const { startScheduler } = await import("@/scheduler/loop");
    startScheduler();
  }

  if (process.env.NEXT_RUNTIME === "edge") {
    await import("../sentry.edge.config");
  }
}

export const onRequestError = Sentry.captureRequestError;
```

**Step 2: Run build to verify**

Run: `npm run build`
Expected: Build succeeds

**Step 3: Commit**

```
feat(instrumentation): start scheduler on Node.js runtime

Scheduler polling loop auto-starts when Next.js server boots.
```

---

## Task 6: Create Scheduled Messages API Routes

**Files:**
- Create: `src/app/api/scheduled/route.ts`
- Create: `src/app/api/scheduled/[id]/route.ts`
- Test: `src/app/api/scheduled/__tests__/route.test.ts`

**Step 1: Write failing tests**

Create `src/app/api/scheduled/__tests__/route.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import type { ScheduledMessage } from "@/db/schema";

const mockListScheduledMessages = vi.fn<() => Promise<ScheduledMessage[]>>();
const mockCreateScheduledMessage = vi.fn<(data: unknown) => Promise<ScheduledMessage>>();
const mockCancelScheduledMessage = vi.fn<(id: string) => Promise<boolean>>();

vi.mock("@/db/queries", () => ({
  listScheduledMessages: () => mockListScheduledMessages(),
  createScheduledMessage: (data: unknown) => mockCreateScheduledMessage(data),
  cancelScheduledMessage: (id: string) => mockCancelScheduledMessage(id),
}));

const MOCK_MSG: ScheduledMessage = {
  id: "sched-1",
  agentId: "michael",
  triggerAt: new Date("2025-01-01T09:00:00Z"),
  prompt: "Morning greeting",
  targetChannelId: "general",
  status: "pending",
  createdAt: new Date("2025-01-01"),
};

describe("GET /api/scheduled", () => {
  beforeEach(() => vi.clearAllMocks());

  it("returns 200 with list of scheduled messages", async () => {
    mockListScheduledMessages.mockResolvedValue([MOCK_MSG]);

    const { GET } = await import("../route");
    const response = await GET();
    const body = await response.json();

    expect(response.status).toBe(200);
    expect(body).toHaveLength(1);
  });
});

describe("POST /api/scheduled", () => {
  beforeEach(() => vi.clearAllMocks());

  it("returns 201 with created scheduled message", async () => {
    mockCreateScheduledMessage.mockResolvedValue(MOCK_MSG);

    const { POST } = await import("../route");
    const request = new Request("http://localhost/api/scheduled", {
      method: "POST",
      body: JSON.stringify({
        agentId: "michael",
        triggerAt: "2025-01-01T09:00:00Z",
        prompt: "Morning greeting",
        targetChannelId: "general",
      }),
      headers: { "Content-Type": "application/json" },
    });
    const response = await POST(request);

    expect(response.status).toBe(201);
  });

  it("returns 400 for missing required fields", async () => {
    const { POST } = await import("../route");
    const request = new Request("http://localhost/api/scheduled", {
      method: "POST",
      body: JSON.stringify({ agentId: "michael" }),
      headers: { "Content-Type": "application/json" },
    });
    const response = await POST(request);

    expect(response.status).toBe(400);
  });
});

describe("DELETE /api/scheduled/[id]", () => {
  beforeEach(() => vi.clearAllMocks());

  it("returns 200 when cancelled", async () => {
    mockCancelScheduledMessage.mockResolvedValue(true);

    const routeModule = await import("../[id]/route");
    const response = await routeModule.DELETE(
      new Request("http://localhost/api/scheduled/sched-1", { method: "DELETE" }),
      { params: Promise.resolve({ id: "sched-1" }) },
    );

    expect(response.status).toBe(200);
  });

  it("returns 404 when not found or already fired", async () => {
    mockCancelScheduledMessage.mockResolvedValue(false);

    const routeModule = await import("../[id]/route");
    const response = await routeModule.DELETE(
      new Request("http://localhost/api/scheduled/nope", { method: "DELETE" }),
      { params: Promise.resolve({ id: "nope" }) },
    );

    expect(response.status).toBe(404);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npx vitest run src/app/api/scheduled/__tests__/route.test.ts --reporter=verbose`
Expected: FAIL — modules not found

**Step 3: Implement GET/POST route**

Create `src/app/api/scheduled/route.ts`:

```typescript
import { z } from "zod/v4";
import { NextResponse } from "next/server";
import {
  listScheduledMessages,
  createScheduledMessage,
} from "@/db/queries";
import { jsonResponse, parseRequestJson, apiHandler } from "@/lib/api-response";

export async function GET() {
  return apiHandler("api.scheduled.list", "http.server", async () => {
    const messages = await listScheduledMessages();
    return jsonResponse(messages);
  });
}

const CreateScheduledSchema = z.object({
  agentId: z.string().min(1),
  triggerAt: z.iso.datetime(),
  prompt: z.string().min(1),
  targetChannelId: z.string().min(1).optional(),
});

export async function POST(request: Request) {
  return apiHandler("api.scheduled.create", "http.server", async () => {
    const body = await parseRequestJson(request);
    if (body instanceof NextResponse) return body;

    const parsed = CreateScheduledSchema.safeParse(body);
    if (!parsed.success) {
      return jsonResponse(
        { error: "Validation failed", issues: parsed.error.issues },
        { status: 400 },
      );
    }

    const message = await createScheduledMessage({
      ...parsed.data,
      triggerAt: new Date(parsed.data.triggerAt),
    });
    return jsonResponse(message, { status: 201 });
  });
}
```

**Step 4: Implement DELETE route**

Create `src/app/api/scheduled/[id]/route.ts`:

```typescript
import { cancelScheduledMessage } from "@/db/queries";
import { jsonResponse, apiHandler } from "@/lib/api-response";

interface RouteContext {
  params: Promise<{ id: string }>;
}

export async function DELETE(_request: Request, context: RouteContext) {
  return apiHandler("api.scheduled.cancel", "http.server", async () => {
    const { id } = await context.params;
    const cancelled = await cancelScheduledMessage(id);

    if (!cancelled) {
      return jsonResponse(
        { error: "Scheduled message not found or already fired/cancelled" },
        { status: 404 },
      );
    }

    return jsonResponse({ success: true });
  });
}
```

**Step 5: Run tests**

Run: `npx vitest run src/app/api/scheduled/__tests__/route.test.ts --reporter=verbose`
Expected: PASS

**Step 6: Commit**

```
feat(api): add /api/scheduled CRUD routes

GET lists all, POST creates new, DELETE cancels pending.
All traced via apiHandler.
```

---

## Task 7: Seed Scheduled Messages

**Files:**
- Modify: `src/db/seed.ts`

**Step 1: Add scheduled message seed data**

After the channel reads section (around line 466), before the summary, add:

```typescript
// 9. Scheduled messages — seed demo schedules
console.log("Seeding scheduled messages...");
const { scheduledMessages: scheduledMessagesTable } = await import("./schema");
await db.delete(scheduledMessagesTable);

const scheduledDefs = [
  {
    agentId: "michael",
    triggerAt: (() => { const d = new Date(); d.setDate(d.getDate() + 1); d.setHours(9, 0, 0, 0); return d; })(),
    prompt: "Good morning! Start the day by posting an enthusiastic greeting in #general. Comment on something happening this week.",
    targetChannelId: "general",
  },
  {
    agentId: "dwight",
    triggerAt: (() => { const d = new Date(); d.setDate(d.getDate() + 1); d.setHours(8, 30, 0, 0); return d; })(),
    prompt: "Post your daily security briefing in #general. Report on any suspicious activity, check fire exits, and remind everyone about safety protocols.",
    targetChannelId: "general",
  },
];

await db.insert(scheduledMessagesTable).values(scheduledDefs);
console.log(`  ${scheduledDefs.length} scheduled messages`);
```

Also update the summary `counts` object to include `scheduledMessages: scheduledDefs.length`.

**Step 2: Run seed**

Run: `npm run db:seed`
Expected: Seed completes with "2 scheduled messages"

**Step 3: Commit**

```
feat(seed): add demo scheduled messages

Michael's morning greeting (9:00 AM) and Dwight's security
briefing (8:30 AM) in #general, both set for tomorrow.
```

---

## Task 8: Full Test Suite Verification

**Step 1: Run all tests**

Run: `npm run test`
Expected: All tests pass

**Step 2: Run linter + typecheck**

Run: `npm run lint && npm run typecheck`
Expected: Clean

**Step 3: Run build**

Run: `npm run build`
Expected: Build succeeds

**Step 4: Final commit if any fixes needed**

---

## Task 9: Manual Demo with Playwright

Verify the scheduler works end-to-end:

1. Start the dev server (`npm run dev`)
2. Create a scheduled message via API (10 seconds from now):
   ```bash
   curl -X POST http://localhost:3040/api/scheduled \
     -H "Content-Type: application/json" \
     -d '{"agentId":"michael","triggerAt":"<10s-from-now>","prompt":"Say hello to everyone in general!","targetChannelId":"general"}'
   ```
3. Wait 10-15 seconds
4. Verify the agent posted in `#general` via Playwright headed mode
5. Check Sentry traces for `scheduler.tick` and `scheduler.fired` spans
